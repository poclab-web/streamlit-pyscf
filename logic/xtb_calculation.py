"""
xTB (extended tight-binding) 計算を実行するためのモジュール

機能:
- xTBによる構造最適化とシングルポイント計算
- ALPB溶媒効果モデルの対応
- エネルギー抽出と結果解析
"""

import subprocess
import os
import re
import platform
import sys
import shutil
import tempfile
import time
from pathlib import Path
from rdkit import Chem
from rdkit.Chem import rdMolDescriptors, AllChem

# xTBで使用可能な理論手法
THEORY_OPTIONS = ["GFN0", "GFN1", "GFN2"]

# 溶媒オプション（ALPB溶媒モデル）
SOLVENT_OPTIONS = [
    "water", "methanol", "ethanol", "acetonitrile", "dmso",
    "chloroform", "toluene", "acetone", "benzene", "octanol"
]

def check_xtb_installation():
    """
    xTBのインストール状況をチェックする
    
    Returns:
        dict: インストール状況の情報
            - installed (bool): インストールされているかどうか
            - version (str): バージョン情報
            - path (str): 実行ファイルのパス
            - error (str): エラーメッセージ
    """
    try:
        result = subprocess.run(["xtb", "--version"], capture_output=True, text=True, timeout=10)
        if result.returncode == 0:
            version_lines = result.stdout.splitlines()
            version_info = ""
            for line in version_lines[:3]:  # 最初の3行を取得
                if line.strip():
                    version_info += line.strip() + "\n"
            
            return {
                'installed': True,
                'version': version_info.strip(),
                'path': "xtb",  # PATHから実行可能
                'error': ""
            }
        else:
            return {
                'installed': False,
                'version': "",
                'path': "",
                'error': f"xTB returned error code: {result.returncode}"
            }
    except FileNotFoundError:
        return {
            'installed': False,
            'version': "",
            'path': "",
            'error': "xTB executable not found in PATH"
        }
    except subprocess.TimeoutExpired:
        return {
            'installed': False,
            'version': "",
            'path': "",
            'error': "xTB version check timed out"
        }
    except Exception as e:
        return {
            'installed': False,
            'version': "",
            'path': "",
            'error': f"Unexpected error: {str(e)}"
        }


class XTBCalculator:
    """
    MoleculeHandlerから受け取った分子データを使ってxTB計算を実行するクラス
    """
    
    def __init__(self, molecule_handler, work_dir=None):
        """
        初期化
        
        Args:
            molecule_handler: MoleculeHandlerのインスタンス
            work_dir: 作業ディレクトリ
        """
        self.molecule_handler = molecule_handler
        
        if work_dir is None:
            try:
                inchikey = Chem.MolToInchiKey(molecule_handler.mol)
            except:
                inchikey = "unknown_molecule"
            work_dir = Path("data") / inchikey / "xtb_results"
        
        self.work_dir = Path(work_dir)
        self.work_dir.mkdir(parents=True, exist_ok=True)
            
    def create_xyz_file(self, filename=None):
        """
        分子のXYZファイルを作成
        
        Args:
            filename: ファイル名（指定しない場合は分子のInChIKeyを使用）
            
        Returns:
            Path: 作成されたXYZファイルのパス
        """
        if not self.molecule_handler.mol:
            raise ValueError("Molecule is not initialized in MoleculeHandler.")
        
        if filename is None:
            try:
                inchikey = Chem.MolToInchiKey(self.molecule_handler.mol)
                filename = f"mol_{inchikey}"
            except:
                timestamp = str(int(time.time() * 1000000))  # マイクロ秒タイムスタンプ
                filename = f"mol_{timestamp}"
        
        xyz_coordinates = self.molecule_handler.get_xyz_coordinates()
        xyz_content = f"{len(xyz_coordinates)}\nGenerated by streamlit-pyscf\n"
        for symbol, x, y, z in xyz_coordinates:
            xyz_content += f"{symbol} {x:.8f} {y:.8f} {z:.8f}\n"
        
        xyz_file = self.work_dir / f"{filename}.xyz"
        with open(xyz_file, "w") as f:
            f.write(xyz_content)
        
        return xyz_file
    
    def create_sdf_file(self, filename=None):
        """
        分子のSDFファイルを作成
        
        Args:
            filename: ファイル名（指定しない場合は分子のInChIKeyを使用）
            
        Returns:
            Path: 作成されたSDFファイルのパス
        """
        if not self.molecule_handler.mol:
            raise ValueError("Molecule is not initialized in MoleculeHandler.")
        
        if filename is None:
            try:
                inchikey = Chem.MolToInchiKey(self.molecule_handler.mol)
                filename = f"mol_{inchikey}"
            except:
                timestamp = str(int(time.time() * 1000000))  # マイクロ秒タイムスタンプ
                filename = f"mol_{timestamp}"
        
        sdf_file = self.work_dir / f"{filename}.sdf"
        self.molecule_handler.save_to_sdf(str(sdf_file))
        
        return sdf_file
    
    def _get_molden_filename(self):
        """
        Moldenファイル名を生成（固定名）
        
        Returns:
            str: Moldenファイル名
        """
        return "xtb.molden"
    
    def run_calculation(self, input_file, calculation_type="sp", gfn=0, charge=0, uhf=0, solvent=None, accuracy=1.0):
        """
        xTB計算を実行（複数の安全な方法を試行）
        
        Args:
            input_file: 入力ファイルのパス（XYZまたはSDF）
            calculation_type: 計算タイプ ("opt", "sp", "freq", "opt+freq")
            gfn: GFNモデル (0, 1, 2)
            charge: 分子電荷
            uhf: 不対電子数
            solvent: 溶媒名
            accuracy: 計算精度 (0.0001-1000, デフォルト1.0、低い値ほど高精度)
            
        Returns:
            dict: 計算結果の情報
        """
        if not Path(input_file).exists():
            return {
                'success': False,
                'error': f'Input file not found: {input_file}',
                'input_file': str(input_file)
            }
        
        # 連続計算（opt+freq）の場合は専用の処理を呼び出し
        if calculation_type == "opt+freq":
            return self._run_optimization_and_frequency(input_file, gfn, charge, uhf, solvent, accuracy)
        
        # 事前チェック：xTBが入力ファイルを正しく読み取れるかテスト
        validation_result = self._validate_input_file(input_file)
        if not validation_result['valid']:
            return {
                'success': False,
                'error': f'Input validation failed: {validation_result["error"]}',
                'input_file': str(input_file)
            }
        
        # xTBのセグメンテーションフォルト対策として複数の方法を試行
        
        # 方法1: 最もシンプルな設定で実行（溶媒なし、GFN0、最小オプション）
        # ただし、振動計算の場合はスキップ（--hessが必要なため）
        if gfn > 0 or solvent or calculation_type == "opt":
            if calculation_type != "freq":  # 振動計算の場合はシンプル計算をスキップ
                simple_result = self._try_simple_calculation(input_file, charge, uhf, accuracy)
                if simple_result['success']:
                    return simple_result
        
        # 方法2: 指定された設定で実行
        result = self._try_calculation_with_settings(input_file, calculation_type, gfn, charge, uhf, solvent, accuracy)
        if result['success']:
            return result
        
        # 方法3: XYZ形式に変換して再試行（SDF形式の場合）
        if str(input_file).endswith('.sdf'):
            xyz_result = self._try_with_xyz_conversion(input_file, calculation_type, gfn, charge, uhf, solvent, accuracy)
            if xyz_result['success']:
                return xyz_result
        
        # すべて失敗した場合は最後の結果を返す
        return result
    
    def _validate_input_file(self, input_file):
        """
        xTBが入力ファイルを正しく処理できるかテスト
        """
        filename = Path(input_file).name
        cmd = ["xtb", filename, "--define"]  # 入力チェックのみ
        
        try:
            result = subprocess.run(
                cmd,
                cwd=self.work_dir,
                capture_output=True,
                text=True,
                timeout=30  # 短時間でタイムアウト
            )
            
            # --defineは常にreturn code 0で終了するため、stdoutをチェック
            if "ERROR" in result.stdout or "FAILED" in result.stdout:
                return {
                    'valid': False,
                    'error': f'Input validation detected issues: {result.stdout}'
                }
            
            # セグメンテーションフォルトが発生した場合
            if result.returncode == -11:
                return {
                    'valid': False,
                    'error': 'Input file causes segmentation fault in xTB'
                }
            
            return {'valid': True, 'error': None}
            
        except subprocess.TimeoutExpired:
            return {
                'valid': False,
                'error': 'Input validation timed out'
            }
        except Exception as e:
            return {
                'valid': False,
                'error': f'Input validation failed: {str(e)}'
            }
    
    def _try_simple_calculation(self, input_file, charge, uhf, accuracy=1.0):
        """
        最もシンプルな設定でxTB計算を試行
        """
        filename = Path(input_file).name
        cmd = ["xtb", filename, "--gfn", "1", "--sp"]  # GFN1、シングルポイントのみ（GFN0は利用不可）
        
        # 電荷設定
        if charge != 0:
            cmd.extend(["--chrg", str(charge)])
        if uhf != 0:
            cmd.extend(["--uhf", str(uhf)])
        
        # 精度設定
        cmd.extend(["--acc", str(accuracy)])
        cmd.append("--ceasefiles")    # 出力ファイル数を削減
        
        # InChIKeyベースのMoldenファイル名を生成
        molden_filename = self._get_molden_filename()
        cmd.append("--molden")  # Moldenファイルを出力（固定名molden.input）
        
        return self._execute_xtb_command(cmd, input_file)
    
    def _try_calculation_with_settings(self, input_file, calculation_type, gfn, charge, uhf, solvent, accuracy=1.0):
        """
        指定された設定でxTB計算を試行
        """
        filename = Path(input_file).name
        cmd = ["xtb", filename]
        
        # 計算タイプの設定
        if calculation_type == "opt":
            cmd.extend(["--opt", "loose"])  # 緩い最適化
        elif calculation_type == "freq":
            cmd.append("--hess")  # 振動計算（ヘッシアン計算）
            cmd.append("--thermo")  # 熱化学補正を追加
            cmd.extend(["--temp", "298.15"])  # 温度設定（298.15 K）
            cmd.extend(["--press", "1.0"])   # 圧力設定（1 atm）
        elif calculation_type == "opt+freq":
            # この場合は別のメソッドで処理
            return self._run_optimization_and_frequency(input_file, gfn, charge, uhf, solvent, accuracy)
        else:
            cmd.append("--sp")
        
        # GFNモデルの設定（GFN0は利用不可なので1以上を使用）
        gfn_version = max(1, gfn)  # GFN0の場合はGFN1に変更
        cmd.extend(["--gfn", str(gfn_version)])
        
        # 電荷と不対電子数の設定
        if charge != 0:
            cmd.extend(["--chrg", str(charge)])
        if uhf != 0:
            cmd.extend(["--uhf", str(uhf)])
        
        # 溶媒効果の設定
        if solvent:
            cmd.extend(["--alpb", solvent])
        
        # 精度設定
        cmd.extend(["--acc", str(accuracy)])
        # cmd.append("--ceasefiles")  # 出力ファイル数を削減
        
        # InChIKeyベースのMoldenファイル名を生成
        molden_filename = self._get_molden_filename()
        cmd.append("--molden")  # Moldenファイルを出力（固定名molden.input）
        
        # デバッグ用：実行コマンドを出力
        print(f"xTB command: {' '.join(cmd)}")
        
        return self._execute_xtb_command(cmd, input_file)
    
    def _try_with_xyz_conversion(self, sdf_file, calculation_type, gfn, charge, uhf, solvent, accuracy=1.0):
        """
        SDF形式をXYZ形式に変換して再試行
        """
        try:
            # XYZファイルを作成
            xyz_file = self.create_xyz_file()
            return self._try_calculation_with_settings(xyz_file, calculation_type, gfn, charge, uhf, solvent, accuracy)
        except Exception as e:
            return {
                'success': False,
                'error': f'XYZ conversion failed: {str(e)}',
                'input_file': str(sdf_file)
            }
    
    def _execute_xtb_command(self, cmd, input_file):
        """
        xTBコマンドを実行（安定化された環境設定付き）
        """
        # xTB安定化のための環境変数設定
        env = os.environ.copy()
        env.update({
            'OMP_NUM_THREADS': '1',  # 単一スレッドで実行
            'MKL_NUM_THREADS': '1',  # Intel MKL使用時の単一スレッド
            'OMP_STACKSIZE': '1G',   # スタックサイズを制限
            'MPLBACKEND': 'Agg'      # matplotlibのバックエンドを安全なものに
        })
        
        try:
            # xTB実行
            result = subprocess.run(
                cmd,
                cwd=self.work_dir,
                capture_output=True,
                text=True,
                timeout=180,  # 3分でタイムアウト（短縮）
                env=env  # 安定化された環境変数
            )
            
            # セグメンテーションフォルトの特別処理
            if result.returncode == -11:  # SIGSEGV
                error_msg = "Program received signal SIGSEGV: Segmentation fault - invalid memory reference."
                if result.stderr:
                    error_msg += f"\n{result.stderr}"
                return {
                    'success': False,
                    'error': error_msg,
                    'input_file': str(input_file),
                    'work_directory': str(self.work_dir),
                    'stdout': result.stdout,
                    'stderr': result.stderr,
                    'return_code': result.returncode,
                    'command_executed': ' '.join(cmd)
                }
            
            # 結果を解析
            if result.returncode == 0:
                # 計算タイプを正しく判定
                actual_calc_type = "freq" if "--hess" in cmd else ("opt" if "--opt" in cmd else "sp")
                return self._process_successful_result(result, input_file, cmd, actual_calc_type)
            else:
                return {
                    'success': False,
                    'input_file': str(input_file),
                    'work_directory': str(self.work_dir),
                    'stdout': result.stdout,
                    'stderr': result.stderr,
                    'return_code': result.returncode,
                    'command_executed': ' '.join(cmd),
                    'energy': None,
                    'error': f"xTB failed with return code {result.returncode}: {result.stderr}"
                }
            
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': 'Calculation timed out (>3 minutes)',
                'input_file': str(input_file),
                'command_executed': ' '.join(cmd)
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'Unexpected error during calculation: {str(e)}',
                'input_file': str(input_file),
                'command_executed': ' '.join(cmd)
            }
    
    def _process_successful_result(self, result, input_file, cmd, calculation_type):
        """
        成功した計算結果を処理する
        
        Args:
            result: subprocess実行結果
            input_file: 入力ファイルパス
            cmd: 実行されたコマンド
            calculation_type: 計算タイプ
            
        Returns:
            dict: 処理された計算結果
        """
        calculation_result = {
            'success': True,
            'input_file': str(input_file),
            'work_directory': str(self.work_dir),
            'stdout': result.stdout,
            'stderr': result.stderr,
            'return_code': result.returncode,
            'command_executed': ' '.join(cmd)
        }
        
        # エネルギーの抽出
        energy = self._extract_energy(result.stdout)
        calculation_result['energy'] = energy
        
        # 最適化構造の読み込み（構造最適化の場合）
        if calculation_type == "opt":
            opt_xyz_file = self._find_optimized_structure_file()
            if opt_xyz_file:
                try:
                    with open(opt_xyz_file, 'r') as f:
                        calculation_result['optimized_xyz'] = f.read()
                    calculation_result['optimized_xyz_file'] = str(opt_xyz_file)
                    print(f"最適化構造を正常に読み込み: {opt_xyz_file.name}")
                except Exception as e:
                    print(f"最適化構造ファイルの読み込みエラー: {str(e)}")
                    calculation_result['optimized_xyz_warning'] = f"ファイル読み込みエラー: {str(e)}"
            else:
                print("最適化構造ファイルが見つかりませんでした")
                calculation_result['optimized_xyz_warning'] = "最適化構造ファイルが見つかりませんでした"
        
        # 振動計算結果の読み込み（振動計算の場合）
        if calculation_type == "freq":
            freq_results = self._parse_frequencies()
            
            # 標準出力からも熱力学データを抽出
            stdout_thermo_data = self._extract_thermodynamic_data(result.stdout)
            for key, value in stdout_thermo_data.items():
                if key not in freq_results or freq_results[key] is None:
                    freq_results[key] = value
            
            calculation_result.update(freq_results)
        
        # 追加の解析結果
        additional_results = self._parse_output(result.stdout)
        calculation_result.update(additional_results)
        
        # Moldenファイルの検索と処理
        molden_file = self._process_molden_file()
        if molden_file:
            calculation_result['molden_file'] = str(molden_file)
            print(f"Moldenファイルを結果に追加: {molden_file.name}")
        else:
            calculation_result['molden_file'] = None
            print("Moldenファイルが見つかりませんでした")
        
        return calculation_result
    
    def _extract_energy(self, stdout):
        """
        xTB出力からエネルギーを抽出
        
        Args:
            stdout: xTBの標準出力
            
        Returns:
            float: エネルギー値（Hartree）、見つからない場合はNone
        """
        energy = None
        for line in stdout.splitlines():
            if "TOTAL ENERGY" in line:
                try:
                    parts = line.split()
                    for i, part in enumerate(parts):
                        if "ENERGY" in part and i + 1 < len(parts):
                            energy = float(parts[i + 1])
                            break
                    if energy is None:
                        energy = float(line.split()[-1])
                    break
                except (ValueError, IndexError):
                    continue
        
        return energy
    
    def _parse_output(self, stdout):
        """
        xTB出力から追加情報を抽出
        
        Args:
            stdout: xTBの標準出力
            
        Returns:
            dict: 抽出された情報
        """
        results = {}
        lines = stdout.splitlines()
        
        # 双極子モーメントの抽出
        for line in lines:
            if "molecular dipole:" in line.lower():
                try:
                    match = re.search(r'(\d+\.?\d*)\s*(?:ea0|debye|au)', line.lower())
                    if match:
                        results['dipole_moment'] = float(match.group(1))
                except (ValueError, AttributeError):
                    pass
        
        # HOMO-LUMOギャップの抽出
        for line in lines:
            if "homo-lumo gap" in line.lower():
                try:
                    match = re.search(r'(\d+\.?\d+)\s*ev', line.lower())
                    if match:
                        results['homo_lumo_gap'] = float(match.group(1))
                except (ValueError, AttributeError):
                    pass
        
        return results

    def _parse_frequencies(self):
        """
        振動計算結果から振動数を抽出
        
        Returns:
            dict: 振動解析結果
        """
        freq_results = {
            'frequencies': [],
            'imaginary_frequencies': [],
            'ir_intensities': [],
            'zero_point_energy': None,
            'thermal_correction': None,
            'enthalpy_correction': None,
            'entropy': None,
            'free_energy_correction': None,
            'num_imaginary': 0
        }
        
        # 優先順位付きでファイルから振動数を探す（実際に生成されるファイルに基づく）
        possible_files = [
            "vibspectrum",        # xTBの主要な振動出力ファイル（最優先）
            "g98.out",           # Gaussian形式の振動解析結果
            "vibrations.out",    # 旧形式（念のため）
            "xtb.out"           # 標準出力ファイル
        ]
        
        frequencies_found = False
        
        for filename in possible_files:
            filepath = self.work_dir / filename
            if filepath.exists():
                try:
                    # vibspectrumファイルの解析（最優先）
                    if filename == "vibspectrum":
                        frequencies_data = self._parse_vibspectrum_file(filepath)
                        if frequencies_data['frequencies']:
                            freq_results.update(frequencies_data)
                            frequencies_found = True
                            break
                    
                    # g98.outファイルの解析
                    elif filename == "g98.out":
                        frequencies_data = self._parse_g98_frequencies(filepath)
                        if frequencies_data['frequencies']:
                            freq_results.update(frequencies_data)
                            frequencies_found = True
                            break
                    
                    # その他のファイルの場合は従来の方法
                    else:
                        with open(filepath, 'r') as f:
                            content = f.read()
                            
                        # 複数のパターンで振動数を抽出
                        patterns = [
                            r'(\d+\.?\d*)\s+cm\^-1',  # 標準形式
                            r'(\d+\.?\d*)\s+cm-1',    # ハイフン形式
                            r'frequency\s*:\s*([+-]?\d+\.?\d*)',  # frequency: 形式
                            r'(\d+\.?\d*)\s*wavenumbers',  # wavenumbers形式
                            r'Frequency\s+([+-]?\d+\.?\d*)',  # Frequency 形式
                            r'([+-]?\d+\.?\d*)\s+\(cm\^-1\)',  # (cm^-1) 形式
                        ]
                        
                        all_frequencies = []
                        for pattern in patterns:
                            matches = re.findall(pattern, content, re.IGNORECASE)
                            if matches:
                                all_frequencies.extend([float(f) for f in matches])
                        
                        if all_frequencies:
                            # 重複を除去してソート
                            unique_frequencies = sorted(list(set(all_frequencies)))
                            freq_results['frequencies'] = unique_frequencies
                            
                            # 虚振動の検出
                            imaginary_freqs = [f for f in unique_frequencies if f < 0]
                            freq_results['imaginary_frequencies'] = imaginary_freqs
                            freq_results['num_imaginary'] = len(imaginary_freqs)
                            
                            frequencies_found = True
                            break
                        
                except Exception as e:
                    freq_results['error'] = f"振動データ読み込みエラー ({filename}): {str(e)}"
        
        # もし振動数が見つからない場合、xtb.outから詳細に探す
        if not frequencies_found:
            xtbout_file = self.work_dir / "xtb.out"
            if xtbout_file.exists():
                try:
                    with open(xtbout_file, 'r') as f:
                        lines = f.readlines()
                    
                    # より詳細な検索
                    frequencies = []
                    in_freq_section = False
                    
                    for line in lines:
                        line = line.strip()
                        
                        # 振動セクションの開始を検出
                        if any(keyword in line.lower() for keyword in 
                               ['frequencies', 'vibrational', 'normal modes', 'harmonic frequencies']):
                            in_freq_section = True
                            continue
                        
                        # 振動セクション内で数値を探す
                        if in_freq_section:
                            # 数値のパターンをより広く検索
                            freq_matches = re.findall(r'([+-]?\d+\.?\d*)', line)
                            for match in freq_matches:
                                try:
                                    freq = float(match)
                                    if -5000 < freq < 5000:  # 妥当な範囲の振動数のみ
                                        frequencies.append(freq)
                                except ValueError:
                                    continue
                        
                        # セクション終了の検出
                        if in_freq_section and (line == '' or 
                                              any(keyword in line.lower() for keyword in 
                                                  ['end', 'summary', 'total energy'])):
                            break
                    
                    if frequencies:
                        unique_frequencies = sorted(list(set(frequencies)))
                        freq_results['frequencies'] = unique_frequencies
                        imaginary_freqs = [f for f in unique_frequencies if f < 0]
                        freq_results['imaginary_frequencies'] = imaginary_freqs
                        frequencies_found = True
                        
                except Exception as e:
                    freq_results['error'] = f"詳細振動データ読み込みエラー: {str(e)}"
        
        # 熱力学データの読み込み（複数ソースから）
        thermodynamic_files = [
            self.work_dir / "xtb.out",
            self.work_dir / "thermodynamics",
            self.work_dir / "thermo.out"
        ]
        
        for thermo_file in thermodynamic_files:
            if thermo_file.exists():
                try:
                    with open(thermo_file, 'r') as f:
                        content = f.read()
                    
                    # 熱力学データを抽出
                    thermo_data = self._extract_thermodynamic_data(content)
                    freq_results.update(thermo_data)
                    break
                    
                except Exception as e:
                    if 'error' not in freq_results:
                        freq_results['error'] = f"熱力学データ読み込みエラー ({thermo_file.name}): {str(e)}"
        
        return freq_results

    def _extract_thermodynamic_data(self, content):
        """
        テキストコンテンツから熱力学データを抽出
        
        Args:
            content: ファイルの内容
            
        Returns:
            dict: 抽出された熱力学データ
        """
        thermo_data = {}
        
        # より詳細な熱力学パラメータの抽出
        # ゼロ点エネルギー
        patterns = [
            r'zero.?point energy\s*:?\s*([+-]?\d+\.?\d*)',
            r'zero.?point vibrational energy\s*:?\s*([+-]?\d+\.?\d*)',
            r'ZPE\s*:?\s*([+-]?\d+\.?\d*)',
            r'zero.?point correction\s*:?\s*([+-]?\d+\.?\d*)'
        ]
        for pattern in patterns:
            zpe_match = re.search(pattern, content, re.IGNORECASE)
            if zpe_match:
                thermo_data['zero_point_energy'] = float(zpe_match.group(1))
                break
        
        # 熱補正
        patterns = [
            r'thermal correction\s*:?\s*([+-]?\d+\.?\d*)',
            r'thermal correction to energy\s*:?\s*([+-]?\d+\.?\d*)',
            r'thermal energy correction\s*:?\s*([+-]?\d+\.?\d*)',
            r'thermal correction to internal energy\s*:?\s*([+-]?\d+\.?\d*)'
        ]
        for pattern in patterns:
            thermal_match = re.search(pattern, content, re.IGNORECASE)
            if thermal_match:
                thermo_data['thermal_correction'] = float(thermal_match.group(1))
                break
        
        # エンタルピー補正
        patterns = [
            r'enthalpy correction\s*:?\s*([+-]?\d+\.?\d*)',
            r'thermal correction to enthalpy\s*:?\s*([+-]?\d+\.?\d*)',
            r'enthalpy\s*:?\s*([+-]?\d+\.?\d*)\s*hartree',
            r'H\s*correction\s*:?\s*([+-]?\d+\.?\d*)'
        ]
        for pattern in patterns:
            enthalpy_match = re.search(pattern, content, re.IGNORECASE)
            if enthalpy_match:
                thermo_data['enthalpy_correction'] = float(enthalpy_match.group(1))
                break
        
        # エントロピー
        patterns = [
            r'entropy\s*:?\s*([+-]?\d+\.?\d*)',
            r'total entropy\s*:?\s*([+-]?\d+\.?\d*)',
            r'S\s*:?\s*([+-]?\d+\.?\d*)\s*cal',
            r'S\s*:?\s*([+-]?\d+\.?\d*)\s*J'
        ]
        for pattern in patterns:
            entropy_match = re.search(pattern, content, re.IGNORECASE)
            if entropy_match:
                thermo_data['entropy'] = float(entropy_match.group(1))
                break
        
        # 自由エネルギー補正
        patterns = [
            r'free energy correction\s*:?\s*([+-]?\d+\.?\d*)',
            r'thermal correction to gibbs free energy\s*:?\s*([+-]?\d+\.?\d*)',
            r'gibbs free energy\s*:?\s*([+-]?\d+\.?\d*)\s*hartree',
            r'G\s*correction\s*:?\s*([+-]?\d+\.?\d*)'
        ]
        for pattern in patterns:
            free_energy_match = re.search(pattern, content, re.IGNORECASE)
            if free_energy_match:
                thermo_data['free_energy_correction'] = float(free_energy_match.group(1))
                break
        
        # 追加の熱力学パラメータ
        # 回転エントロピー
        rot_entropy_match = re.search(r'rotational entropy\s*:?\s*([+-]?\d+\.?\d*)', content, re.IGNORECASE)
        if rot_entropy_match:
            thermo_data['rotational_entropy'] = float(rot_entropy_match.group(1))
        
        # 振動エントロピー
        vib_entropy_match = re.search(r'vibrational entropy\s*:?\s*([+-]?\d+\.?\d*)', content, re.IGNORECASE)
        if vib_entropy_match:
            thermo_data['vibrational_entropy'] = float(vib_entropy_match.group(1))
        
        # 熱容量
        cv_pattern = r'heat capacity\s*:?\s*([+-]?\d+\.?\d*)'
        cv_match = re.search(cv_pattern, content, re.IGNORECASE)
        if cv_match:
            thermo_data['heat_capacity'] = float(cv_match.group(1))
        
        # 温度情報の抽出
        temp_pattern = r'temperature\s*:?\s*([+-]?\d+\.?\d*)\s*K'
        temp_match = re.search(temp_pattern, content, re.IGNORECASE)
        if temp_match:
            thermo_data['temperature'] = float(temp_match.group(1))
        
        # 圧力情報の抽出
        press_pattern = r'pressure\s*:?\s*([+-]?\d+\.?\d*)\s*(?:atm|bar|Pa)'
        press_match = re.search(press_pattern, content, re.IGNORECASE)
        if press_match:
            thermo_data['pressure'] = float(press_match.group(1))
            
        return thermo_data

    def _parse_vibspectrum_file(self, file_path):
        """
        xTBのvibspectrumファイルから振動データを抽出する
        
        Args:
            file_path: vibspectrumファイルのパス
            
        Returns:
            dict: 抽出された振動データ
        """
        frequencies_data = {
            'frequencies': [],
            'imaginary_frequencies': [],
            'ir_intensities': [],
            'num_imaginary': 0
        }
        
        try:
            with open(file_path, "r") as f:
                lines = f.readlines()
                
            parsing_data = False
            for line in lines:
                line_stripped = line.strip()
                
                # データセクションの開始を検出
                if "$vibrational spectrum" in line:
                    parsing_data = True
                    continue
                elif "$end" in line:
                    break
                elif line_stripped.startswith("#") or not line_stripped:
                    continue
                elif parsing_data:
                    # データ行を解析
                    parts = line_stripped.split()
                    if len(parts) >= 4:
                        try:
                            mode_num = int(parts[0])
                            frequency = float(parts[2])  # wave number
                            ir_intensity = float(parts[3]) if len(parts) > 3 else 0.0
                            
                            # 0に近い値（並進・回転モード）は除外
                            if abs(frequency) > 0.01:
                                frequencies_data['frequencies'].append(frequency)
                                frequencies_data['ir_intensities'].append(ir_intensity)
                                
                                # 虚振動の検出
                                if frequency < 0:
                                    frequencies_data['imaginary_frequencies'].append(frequency)
                            
                        except (ValueError, IndexError):
                            continue
            
            # 虚振動の数をカウント
            frequencies_data['num_imaginary'] = len(frequencies_data['imaginary_frequencies'])
            
            return frequencies_data
            
        except Exception as e:
            print(f"vibspectrum解析エラー: {str(e)}")
            return {'frequencies': [], 'imaginary_frequencies': [], 'ir_intensities': [], 'num_imaginary': 0}

    def _parse_g98_frequencies(self, file_path):
        """
        g98.outファイルから振動データを抽出する
        
        Args:
            file_path: g98.outファイルのパス
            
        Returns:
            dict: 抽出された振動データ
        """
        frequencies_data = {
            'frequencies': [],
            'imaginary_frequencies': [],
            'ir_intensities': [],
            'num_imaginary': 0
        }
        
        try:
            with open(file_path, "r") as f:
                content = f.read()
                
            # Gaussian形式の振動数を抽出
            freq_pattern = r'Frequencies --\s+([\d\.\-\s]+)'
            ir_pattern = r'IR Inten\s+--\s+([\d\.\-\s]+)'
            
            freq_matches = re.findall(freq_pattern, content)
            ir_matches = re.findall(ir_pattern, content)
            
            all_frequencies = []
            all_ir_intensities = []
            
            # 振動数を抽出
            for match in freq_matches:
                freqs = [float(f) for f in match.split() if f.strip()]
                all_frequencies.extend(freqs)
            
            # IR強度を抽出
            for match in ir_matches:
                intensities = [float(i) for i in match.split() if i.strip()]
                all_ir_intensities.extend(intensities)
            
            # 有効な振動数のみを保持（0に近い値は除外）
            valid_frequencies = []
            valid_ir_intensities = []
            imaginary_frequencies = []
            
            for i, freq in enumerate(all_frequencies):
                if abs(freq) > 0.01:  # 0に近い値（並進・回転モード）は除外
                    valid_frequencies.append(freq)
                    if i < len(all_ir_intensities):
                        valid_ir_intensities.append(all_ir_intensities[i])
                    
                    if freq < 0:
                        imaginary_frequencies.append(freq)
            
            frequencies_data['frequencies'] = valid_frequencies
            frequencies_data['ir_intensities'] = valid_ir_intensities
            frequencies_data['imaginary_frequencies'] = imaginary_frequencies
            frequencies_data['num_imaginary'] = len(imaginary_frequencies)
            
            return frequencies_data
            
        except Exception as e:
            print(f"g98.out解析エラー: {str(e)}")
            return {'frequencies': [], 'imaginary_frequencies': [], 'ir_intensities': [], 'num_imaginary': 0}

    def _parse_xtb_vibrations(self, file_path):
        """
        レガシー: xTBのvibrations.outから振動数(cm^-1)を抽出する
        注意: このメソッドは古い形式のvibrations.outファイル用です。
        現在のxTBは主にvibspectrumファイルを使用します。
        
        Args:
            file_path: vibrations.outファイルのパス
            
        Returns:
            list: 振動数のリスト
        """
        frequencies = []
        try:
            with open(file_path, "r") as f:
                lines = f.readlines()
                
            start = False
            for line in lines:
                line_stripped = line.strip()
                
                # 振動解析セクションの開始を検出
                if "VIBRATIONAL ANALYSIS" in line or "NORMAL MODE EIGENVALUES" in line:
                    start = True
                    continue
                elif start and line_stripped.startswith("Mode"):
                    # ヘッダー行をスキップ
                    continue
                elif start:
                    # 空行で終了
                    if line_stripped == "":
                        break
                    
                    # データ行を解析
                    parts = line_stripped.split()
                    if len(parts) >= 2:
                        try:
                            # 通常、2番目のカラムが振動数
                            freq = float(parts[1])
                            frequencies.append(freq)
                        except (ValueError, IndexError):
                            # 別のフォーマットを試す
                            try:
                                # 最初のカラムが振動数の場合
                                freq = float(parts[0])
                                if abs(freq) < 10000:  # 妥当な範囲チェック
                                    frequencies.append(freq)
                            except (ValueError, IndexError):
                                continue
                    
                    # もし"cm-1"または"cm^-1"が含まれている行なら、その前の数値を抽出
                    if "cm-1" in line or "cm^-1" in line:
                        # 正規表現で数値を抽出
                        import re
                        freq_matches = re.findall(r'([+-]?\d+\.?\d*)\s*cm', line)
                        for match in freq_matches:
                            try:
                                freq = float(match)
                                frequencies.append(freq)
                            except ValueError:
                                continue
            
            return frequencies
            
        except Exception as e:
            print(f"vibrations.out解析エラー: {str(e)}")
            return []
    
    def _find_optimized_structure_file(self):
        """
        最適化計算後に生成される構造ファイルを包括的に検索
        
        Returns:
            Path: 見つかった最適化構造ファイルのパス、見つからない場合はNone
        """
        # 実行前に作業ディレクトリのファイル一覧をデバッグ出力
        all_files_before = list(self.work_dir.glob("*"))
        print(f"検索開始時の作業ディレクトリ内ファイル: {[f.name for f in all_files_before]}")
        
        # xTBが生成する可能性のあるファイル名（優先順位順）
        candidate_files = [
            "xtbopt.xyz",          # 最も一般的
            "xtbopt.coord",        # TURBOMOLE座標形式
            "xtbopt.sdf",          # SDF形式出力
            "optimized.xyz",       # 一般的な名前
            "opt.xyz",            # 短縮形
            "structure.xyz",       # 別の一般的な名前
            "final.xyz",          # 最終構造
            "xtb.xyz",           # 基本名
            "output.xyz",         # 出力構造
            "coord"               # TURBOMOLE標準ファイル名
        ]
        
        # 基本的なファイル名による検索
        for filename in candidate_files:
            file_path = self.work_dir / filename
            if file_path.exists() and file_path.is_file() and file_path.stat().st_size > 0:
                print(f"最適化構造ファイルを発見: {filename} (サイズ: {file_path.stat().st_size} bytes)")
                
                # .coordファイルの場合はXYZに変換
                if filename.endswith('.coord') or filename == 'coord':
                    xyz_file = self._convert_coord_to_xyz(file_path)
                    if xyz_file:
                        return xyz_file
                
                return file_path
        
        # パターンマッチングによる検索
        # xtbで始まるXYZファイル
        for file_path in self.work_dir.glob("xtb*.xyz"):
            if file_path.is_file() and file_path.stat().st_size > 0:
                print(f"パターンマッチで最適化構造ファイルを発見: {file_path.name}")
                return file_path
        
        # optで始まるファイル
        for file_path in self.work_dir.glob("opt*.xyz"):
            if file_path.is_file() and file_path.stat().st_size > 0:
                print(f"パターンマッチで最適化構造ファイルを発見: {file_path.name}")
                return file_path
        
        # coordファイルの検索（TURBOMOLE形式）
        coord_files = [f for f in self.work_dir.glob("*.coord") if f.is_file() and f.stat().st_size > 0]
        if coord_files:
            # 最新のcoordファイルを選択
            coord_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
            latest_coord = coord_files[0]
            print(f"coordファイルを発見: {latest_coord.name}")
            
            # coordファイルをXYZに変換
            xyz_from_coord = self._convert_coord_to_xyz(latest_coord)
            if xyz_from_coord:
                print(f"coordファイルからXYZに変換成功: {latest_coord.name} -> {xyz_from_coord.name}")
                return xyz_from_coord
        
        # 全てのXYZファイルから適切なものを選択（最後の手段）
        xyz_files = [f for f in self.work_dir.glob("*.xyz") if f.is_file() and f.stat().st_size > 0]
        if xyz_files:
            # 入力ファイルを除外
            input_patterns = ["mol_", "input", "molecule"]
            output_xyz_files = []
            
            for xyz_file in xyz_files:
                is_input = any(pattern in xyz_file.name.lower() for pattern in input_patterns)
                if not is_input:
                    output_xyz_files.append(xyz_file)
            
            if output_xyz_files:
                # 作成時間順にソート（最新を選択）
                output_xyz_files.sort(key=lambda x: x.stat().st_mtime, reverse=True)
                latest_xyz = output_xyz_files[0]
                print(f"最新の出力XYZファイルを最適化構造として使用: {latest_xyz.name}")
                return latest_xyz
        
        print("最適化構造ファイルが見つかりませんでした")
        print(f"最終的な作業ディレクトリ内ファイル: {[f.name for f in self.work_dir.glob('*')]}")
        return None
    
    def _convert_coord_to_xyz(self, coord_file):
        """
        TURBOMOLE coord形式をXYZ形式に変換
        
        Args:
            coord_file: coord形式ファイルのパス
            
        Returns:
            Path: 変換されたXYZファイルのパス、失敗時はNone
        """
        try:
            xyz_content = []
            atom_count = 0
            
            with open(coord_file, 'r') as f:
                lines = f.readlines()
            
            # coord形式を解析
            atoms = []
            for line in lines:
                line = line.strip()
                if line and not line.startswith('$'):
                    parts = line.split()
                    if len(parts) >= 4:
                        # Bohrから Angstromに変換 (1 Bohr = 0.529177 Angstrom)
                        bohr_to_angstrom = 0.529177249
                        x = float(parts[0]) * bohr_to_angstrom
                        y = float(parts[1]) * bohr_to_angstrom
                        z = float(parts[2]) * bohr_to_angstrom
                        element = parts[3]
                        atoms.append((element, x, y, z))
                        atom_count += 1
            
            if atoms:
                # XYZ形式で書き出し
                xyz_file = self.work_dir / f"{coord_file.stem}.xyz"
                with open(xyz_file, 'w') as f:
                    f.write(f"{atom_count}\n")
                    f.write(f"Converted from {coord_file.name}\n")
                    for element, x, y, z in atoms:
                        f.write(f"{element} {x:.8f} {y:.8f} {z:.8f}\n")
                
                return xyz_file
            
        except Exception as e:
            print(f"coord -> xyz変換エラー: {str(e)}")
        
        return None
    
    def _process_molden_file(self):
        """
        Moldenファイルを処理（リネーム処理を含む）
        
        Returns:
            Path: 処理されたMoldenファイルのパス、見つからない場合はNone
        """
        # xTBが生成するデフォルトのMoldenファイル
        default_molden = self.work_dir / "molden.input"
        target_molden = self.work_dir / "xtb.molden"
        
        # molden.inputが存在する場合、xtb.moldenにリネーム
        if default_molden.exists() and default_molden.is_file() and default_molden.stat().st_size > 0:
            try:
                # 既存のxtb.moldenがある場合は削除
                if target_molden.exists():
                    target_molden.unlink()
                
                # molden.input を xtb.molden にリネーム
                default_molden.rename(target_molden)
                print(f"Moldenファイルをリネーム: molden.input -> xtb.molden")
                return target_molden
            except Exception as e:
                print(f"Moldenファイルのリネームに失敗: {str(e)}")
                # リネームに失敗した場合は元のファイルを返す
                return default_molden
        
        # リネーム処理後、通常の検索を実行
        return self._find_molden_file()
    
    def _find_molden_file(self):
        """
        計算後に生成されるMoldenファイルを検索
        
        Returns:
            Path: 見つかったMoldenファイルのパス、見つからない場合はNone
        """
        # xTBが生成する可能性のあるMoldenファイル名（優先順位順）
        candidate_files = [
            "xtb.molden",         # 最優先（デフォルト出力）
            "molden.input",       # 従来の一般的な名前
            "molecule.molden",    # 別の可能性
            "output.molden",      # 出力形式
            "result.molden"       # 結果形式
        ]
        
        # 基本的なファイル名による検索
        for filename in candidate_files:
            file_path = self.work_dir / filename
            if file_path.exists() and file_path.is_file() and file_path.stat().st_size > 0:
                print(f"Moldenファイルを発見: {filename} (サイズ: {file_path.stat().st_size} bytes)")
                return file_path
        
        # パターンマッチングによる検索
        # .moldenで終わるファイル
        for file_path in self.work_dir.glob("*.molden"):
            if file_path.is_file() and file_path.stat().st_size > 0:
                print(f"パターンマッチでMoldenファイルを発見: {file_path.name}")
                return file_path
        
        # .molで終わるファイル（短縮形）
        for file_path in self.work_dir.glob("*.mol"):
            if file_path.is_file() and file_path.stat().st_size > 0:
                # ファイル内容を確認してMolden形式かチェック
                try:
                    with open(file_path, 'r') as f:
                        first_line = f.readline().strip()
                        if '[Molden Format]' in first_line or 'molden' in first_line.lower():
                            print(f"Molden形式ファイルを発見: {file_path.name}")
                            return file_path
                except:
                    continue
        
        print("Moldenファイルが見つかりませんでした")
        return None

    def _run_optimization_and_frequency(self, input_file, gfn, charge, uhf, solvent, accuracy=1.0):
        """
        構造最適化後に振動計算を実行する
        
        Args:
            input_file: 入力ファイルのパス
            gfn: GFNモデル
            charge: 分子電荷
            uhf: 不対電子数
            solvent: 溶媒名
            accuracy: 計算精度
            
        Returns:
            dict: 統合された計算結果
        """
        try:
            # ステップ1: 構造最適化を実行
            opt_result = self._try_calculation_with_settings(
                input_file, "opt", gfn, charge, uhf, solvent, accuracy
            )
            
            if not opt_result['success']:
                return {
                    'success': False,
                    'error': f"構造最適化が失敗しました: {opt_result.get('error', '不明なエラー')}",
                    'optimization_result': opt_result,
                    'input_file': str(input_file)
                }
            
            # 最適化された構造ファイルを確認
            opt_xyz_file = self._find_optimized_structure_file()
            
            if not opt_xyz_file:
                # 作業ディレクトリの全ファイルをリストアップ（デバッグ用）
                all_files = list(self.work_dir.glob("*"))
                return {
                    'success': False,
                    'error': "最適化された構造ファイルが見つかりません",
                    'optimization_result': opt_result,
                    'input_file': str(input_file),
                    'work_directory_files': [str(f) for f in all_files],
                    'debug_info': {
                        'work_dir': str(self.work_dir),
                        'file_count': len(all_files),
                        'xyz_files': [str(f) for f in all_files if f.suffix.lower() == '.xyz'],
                        'coord_files': [str(f) for f in all_files if f.suffix.lower() == '.coord'],
                        'all_extensions': list(set(f.suffix.lower() for f in all_files if f.is_file()))
                    }
                }
            
            # ステップ2: 最適化された構造で振動計算を実行
            freq_result = self._try_calculation_with_settings(
                opt_xyz_file, "freq", gfn, charge, uhf, solvent, accuracy
            )
            
            if not freq_result['success']:
                # 振動計算が失敗しても、最適化結果は返す
                combined_result = opt_result.copy()
                combined_result['frequency_calculation_failed'] = True
                combined_result['frequency_error'] = freq_result.get('error', '不明なエラー')
                combined_result['warning'] = "構造最適化は成功しましたが、振動計算が失敗しました"
                return combined_result
            
            # ステップ3: 結果を統合
            combined_result = opt_result.copy()
            
            # 振動計算結果を追加
            for key, value in freq_result.items():
                if key.startswith('freq') or key in ['frequencies', 'imaginary_frequencies', 
                                                   'zero_point_energy', 'thermal_correction',
                                                   'enthalpy_correction', 'entropy', 
                                                   'free_energy_correction']:
                    combined_result[key] = value
            
            # 計算タイプを更新
            combined_result['calculation_type'] = 'opt+freq'
            combined_result['optimization_successful'] = True
            combined_result['frequency_calculation_successful'] = True
            
            # エネルギー関連の統合
            if 'energy' in freq_result:
                combined_result['final_energy'] = freq_result['energy']  # 振動計算時のエネルギー
                combined_result['optimization_energy'] = opt_result.get('energy')
            
            # ログメッセージの統合
            combined_result['optimization_stdout'] = opt_result.get('stdout', '')
            combined_result['frequency_stdout'] = freq_result.get('stdout', '')
            
            return combined_result
            
        except Exception as e:
            return {
                'success': False,
                'error': f"opt+freq計算中にエラーが発生しました: {str(e)}",
                'input_file': str(input_file)
            }


def run_xtb_calculation(molecule_handler, work_dir, calculation_type="sp", gfn=0, 
                       charge=0, uhf=0, solvent=None, input_format="sdf", accuracy=1.0):
    """
    Streamlit用の簡単なxTB計算実行関数
    
    Args:
        molecule_handler: MoleculeHandlerインスタンス
        work_dir: 作業ディレクトリ
        calculation_type: "sp" (single point), "opt" (optimization), "freq" (frequency), or "opt+freq" (optimization + frequency)
        gfn: GFNモデル (0, 1, 2)
        charge: 分子電荷
        uhf: 不対電子数
        solvent: 溶媒名
        input_format: 入力ファイル形式 ("sdf" or "xyz")
        accuracy: 計算精度 (0.0001-1000, デフォルト1.0、低い値ほど高精度)
    
    Returns:
        dict: 計算結果
    """
    try:
        calculator = XTBCalculator(molecule_handler, work_dir)
        
        # 入力ファイル形式に応じてファイルを作成
        if input_format.lower() == "sdf":
            input_file = calculator.create_sdf_file()
        else:
            input_file = calculator.create_xyz_file()
        
        result = calculator.run_calculation(
            input_file, calculation_type, gfn, charge, uhf, solvent, accuracy
        )
        return result
    except Exception as e:
        return {
            'success': False,
            'error': f'Calculator initialization failed: {str(e)}'
        }

